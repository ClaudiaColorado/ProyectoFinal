name: Deploy Databricks Workflow (WF_ProyectoFinal)

on:
  workflow_dispatch:
    inputs:
      run_now:
        description: "Ejecutar el workflow despu√©s del deploy"
        type: boolean
        default: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Asegurar jq
        shell: bash
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Setup Databricks CLI
        uses: databricks/setup-cli@v0.270.0

      # üîê Unificamos credenciales DEST y respetamos tus variables existentes
      - name: Exportar variables DEST al entorno
        shell: bash
        run: |
          set -euo pipefail
          # DEST: preferimos variables ya definidas; si no, caemos a secrets/vars
          HOST="${DEST_HOST:-${{ secrets.DEST_HOST }}}"
          [[ -z "$HOST" ]] && HOST="${{ secrets.DATABRICKS_DEST_HOST }}"
          TOKEN="${DEST_TOKEN:-${{ secrets.DEST_TOKEN }}}"
          [[ -z "$TOKEN" ]] && TOKEN="${{ secrets.DATABRICKS_DEST_TOKEN }}"
          CLUSTER="${DEST_CLUSTER_ID:-${{ vars.DEST_CLUSTER_ID }}}"
          BASE="${WORKSPACE_BASE:-${{ vars.WORKSPACE_BASE }}}"

          if [[ -z "$HOST" ]]; then echo "‚ùå Falta DEST_HOST (o secret DEST_HOST / DATABRICKS_DEST_HOST)"; exit 1; fi
          if [[ -z "$TOKEN" ]]; then echo "‚ùå Falta DEST_TOKEN (o secret DEST_TOKEN / DATABRICKS_DEST_TOKEN)"; exit 1; fi
          if [[ -z "$CLUSTER" ]]; then echo "‚ùå Falta DEST_CLUSTER_ID (o var DEST_CLUSTER_ID)"; exit 1; fi
          if [[ -z "$BASE" ]]; then echo "‚ùå Falta WORKSPACE_BASE (o var WORKSPACE_BASE)"; exit 1; fi

          echo "DEST_HOST=$HOST" >> $GITHUB_ENV
          echo "DEST_CLUSTER_ID=$CLUSTER" >> $GITHUB_ENV
          echo "WORKSPACE_BASE=$BASE" >> $GITHUB_ENV

          # El CLI usa estos dos nombres:
          echo "DATABRICKS_HOST=$HOST" >> $GITHUB_ENV
          echo "::add-mask::$TOKEN"
          echo "DATABRICKS_TOKEN=$TOKEN" >> $GITHUB_ENV

          echo "üö© DEST_HOST=$HOST"
          echo "üö© DEST_CLUSTER_ID=$CLUSTER"
          echo "üö© WORKSPACE_BASE=$BASE"

      - name: Mostrar tareas del workflow
        shell: bash
        run: |
          echo "üöÄ Workflow: Proyecto Final"
          echo "  1) üßπ  drop_medallion"
          echo "  2) üß∞  00_prep_env"
          echo "  3) üõ¢Ô∏è‚¨áÔ∏è 01_ingest"
          echo "  4) üîÑ  02_transform"
          echo "  5) üõ¢Ô∏è‚¨ÜÔ∏è 03_load"

      # ‚¨áÔ∏è Export desde ORIGIN si hay secrets de origen (se omite si no existen)
      - name: Export multiple notebooks (raw) desde ORIGIN (opcional)
        shell: bash
        run: |
          set -euo pipefail
          ORIGIN_HOST='${{ secrets.DATABRICKS_ORIGIN_HOST }}'
          ORIGIN_TOKEN='${{ secrets.DATABRICKS_ORIGIN_TOKEN }}'
          # Usa ORIGIN_WORKSPACE_BASE si existe, sino el mismo WORKSPACE_BASE
          ORIGIN_BASE='${{ vars.ORIGIN_WORKSPACE_BASE }}'
          if [[ -z "$ORIGIN_BASE" || "$ORIGIN_BASE" == "null" ]]; then ORIGIN_BASE="${WORKSPACE_BASE}"; fi

          if [[ -z "$ORIGIN_HOST" || -z "$ORIGIN_TOKEN" ]]; then
            echo "‚ÑπÔ∏è No hay credenciales de ORIGIN: se omite export."
          else
            echo "üì§ Exportando desde ORIGIN: ${ORIGIN_BASE} ‚Üí ./exported"
            mkdir -p exported
            DATABRICKS_HOST="$ORIGIN_HOST" DATABRICKS_TOKEN="$ORIGIN_TOKEN" \
              databricks workspace export-dir "$ORIGIN_BASE" ./exported --overwrite
          fi

      # ‚¨áÔ∏è Import a DEST: si hay ./exported, lo sube; si no, contin√∫a (asumes ya est√°n en el workspace)
      - name: Deploy notebooks to Destination Workspace
        shell: bash
        run: |
          set -euo pipefail
          if [[ -d "./exported" ]]; then
            echo "üì• Importando a DEST: ./exported ‚Üí ${WORKSPACE_BASE}"
            databricks workspace import-dir ./exported "${WORKSPACE_BASE}" --overwrite
          else
            echo "‚ÑπÔ∏è No existe ./exported; se asume que los notebooks ya est√°n en ${WORKSPACE_BASE}."
          fi

      - name: Render job.json
        shell: bash
        run: |
          set -euo pipefail
          cat > job.json <<'JSON'
          {
            "name": "WF_ProyectoFinal",
            "max_concurrent_runs": 1,
            "tasks": [
              {
                "task_key": "drop_medallion",
                "notebook_task": { "notebook_path": "__WORKSPACE_BASE__/drop_medallion" },
                "existing_cluster_id": "__CLUSTER_ID__",
                "timeout_seconds": 3600
              },
              {
                "task_key": "00_prep_env",
                "depends_on": [{ "task_key": "drop_medallion" }],
                "notebook_task": { "notebook_path": "__WORKSPACE_BASE__/00_prep_env" },
                "existing_cluster_id": "__CLUSTER_ID__",
                "timeout_seconds": 3600
              },
              {
                "task_key": "01_ingest",
                "depends_on": [{ "task_key": "00_prep_env" }],
                "notebook_task": { "notebook_path": "__WORKSPACE_BASE__/01_ingest.py" },
                "existing_cluster_id": "__CLUSTER_ID__",
                "timeout_seconds": 3600
              },
              {
                "task_key": "02_transform",
                "depends_on": [{ "task_key": "01_ingest" }],
                "notebook_task": { "notebook_path": "__WORKSPACE_BASE__/02_transform.py" },
                "existing_cluster_id": "__CLUSTER_ID__",
                "timeout_seconds": 3600
              },
              {
                "task_key": "03_load",
                "depends_on": [{ "task_key": "02_transform" }],
                "notebook_task": { "notebook_path": "__WORKSPACE_BASE__/03_load" },
                "existing_cluster_id": "__CLUSTER_ID__",
                "timeout_seconds": 3600
              }
            ]
          }
          JSON

          sed -i "s#__WORKSPACE_BASE__#${WORKSPACE_BASE}#g" job.json
          sed -i "s/__CLUSTER_ID__/${DEST_CLUSTER_ID}/g" job.json
          jq . job.json

      - name: Upsert del job (create o reset)
        shell: bash
        run: |
          set -euo pipefail
          JOB_ID=$(databricks jobs list --output JSON | jq -r '.jobs[] | select(.settings.name=="WF_ProyectoFinal") | .job_id' || true)
          if [ -n "${JOB_ID}" ]; then
            echo "Job existente: ${JOB_ID} ‚Üí reset con nueva configuraci√≥n"
            databricks jobs reset --job-id "${JOB_ID}" --json-file job.json
          else
            echo "Creando nuevo job WF_ProyectoFinal"
            CREATE_OUT=$(databricks jobs create --json-file job.json)
            JOB_ID=$(echo "$CREATE_OUT" | jq -r '.job_id')
            if [ -z "${JOB_ID}" ] || [ "${JOB_ID}" = "null" ]; then
              echo "‚ùå No se obtuvo job_id al crear el job"; echo "$CREATE_OUT"; exit 1
            fi
          fi
          echo "JOB_ID=${JOB_ID}" >> $GITHUB_ENV
          echo "‚úÖ Job listo con ID: ${JOB_ID}"

      # üîé Validaci√≥n robusta: separa c√≥digo HTTP y body, y valida JSON (anti exit code 3)
      - name: Validar workflow y evitar exit code 3 de jq
        shell: bash
        run: |
          set -Eeuo pipefail

          call_api () {
            local method="$1"
            local url="$2"
            local body="${3:-}"

            if [[ -n "$body" ]]; then
              resp=$(curl -sS -X "$method" "$url" \
                -H "Authorization: Bearer $DATABRICKS_TOKEN" \
                -H "Content-Type: application/json" \
                -d "$body" -w '\n%{http_code}')
            else
              resp=$(curl -sS -X "$method" "$url" \
                -H "Authorization: Bearer $DATABRICKS_TOKEN" \
                -H "Content-Type: application/json" \
                -w '\n%{http_code}')
            fi

            code=$(echo "$resp" | tail -n1)
            body=$(echo "$resp" | sed '$d')

            if [[ ! "$code" =~ ^2 ]]; then
              echo "‚ùå HTTP $code en $url"
              echo "‚Äî‚Äî Respuesta cruda ‚Äî‚Äî"
              echo "$body"
              exit 1
            fi

            if ! echo "$body" | jq -e . >/dev/null 2>&1; then
              echo "‚ùå La respuesta no es JSON v√°lido para $url"
              echo "‚Äî‚Äî Respuesta cruda ‚Äî‚Äî"
              echo "$body"
              exit 1
            fi

            echo "$body"
          }

          echo "üîç Validando la configuraci√≥n del workflow creado..."
          WF=$(call_api GET "$DATABRICKS_HOST/api/2.1/jobs/get?job_id=${JOB_ID}")
          echo "‚úÖ Workflow encontrado con ID: $(echo "$WF" | jq -r '.job_id')"
          echo "üß© Nombre: $(echo "$WF" | jq -r '.settings.name')"
          echo "üì¶ Tareas:"
          echo "$WF" | jq -r '.settings.tasks[] | "- \(.task_key) -> \(.notebook_task.notebook_path)"'

      - name: Ejecutar workflow (opcional) y esperar a que termine
        if: ${{ inputs.run_now }}
        shell: bash
        run: |
          set -euo pipefail
          echo "‚è© Lanzando ejecuci√≥n para JOB_ID=${JOB_ID}"
          RUN_OUT=$(databricks jobs run-now --job-id "${JOB_ID}")
          echo "$RUN_OUT" | jq .
          RUN_ID=$(echo "$RUN_OUT" | jq -r '.run_id')
          if [ -z "${RUN_ID}" ] || [ "${RUN_ID}" = "null" ]; then
            echo "‚ùå No se obtuvo run_id al ejecutar el job"; exit 1
          fi
          echo "RUN_ID=${RUN_ID}" >> $GITHUB_ENV

          echo "‚è≥ Esperando a que termine la ejecuci√≥n‚Ä¶"
          databricks runs wait --run-id "${RUN_ID}" --timeout 7200
          echo "‚úÖ Ejecuci√≥n completada."
          echo "üß≠ Workflow ejecutado autom√°ticamente"
          echo ""
          echo "üîó Accede a tu workspace de Databricks para ver los resultados detallados:"
          echo "   ${DATABRICKS_HOST}/#job/${JOB_ID}/run/${RUN_ID}"

      - name: Resumen con iconos
        if: ${{ always() }}
        shell: bash
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## üß≠ Pipeline ‚Äî Proyecto Final
          1. üßπ **drop_medallion**
          2. üß∞ **00_prep_env**
          3. üõ¢Ô∏è‚¨áÔ∏è **01_ingest**
          4. üîÑ **02_transform**
          5. üõ¢Ô∏è‚¨ÜÔ∏è **03_load**

          ---
          ### üß≠ Workflow ejecutado autom√°ticamente
          üîó Accede a tu workspace de Databricks para ver los resultados detallados:  
          ${DATABRICKS_HOST}/#job/${JOB_ID}/run/${RUN_ID}
          EOF
